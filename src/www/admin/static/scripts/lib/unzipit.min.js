/* unzipit@1.3.6, license MIT */
!function(){function e(e){return e.arrayBuffer?e.arrayBuffer():new Promise(((t,r)=>{const n=new FileReader;n.addEventListener("loadend",(()=>{t(n.result)})),n.addEventListener("error",r),n.readAsArrayBuffer(e)}))}function t(e){return"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer}"undefined"!=typeof process&&process.versions&&void 0!==process.versions.node&&process.versions.electron;class r{constructor(e){this.blob=e}async getLength(){return this.blob.size}async read(t,r){const n=this.blob.slice(t,t+r),i=await e(n);return new Uint8Array(i)}async sliceAsBlob(e,t,r=""){return this.blob.slice(e,e+t,r)}}function n(e,t){for(var r,n,i,o,a=e.length,f=s.bl_count,c=0;c<=t;c++)f[c]=0;for(c=1;c<a;c+=2)f[e[c]]++;var d=s.next_code;for(r=0,f[0]=0,n=1;n<=t;n++)r=r+f[n-1]<<1,d[n]=r;for(i=0;i<a;i+=2)0!=(o=e[i+1])&&(e[i]=d[o],d[o]++)}function i(e,t,r){for(var n=e.length,i=s.rev15,o=0;o<n;o+=2)if(0!=e[o+1])for(var a=o>>1,f=e[o+1],c=a<<4|f,d=t-f,l=e[o]<<d,u=l+(1<<d);l!=u;){r[i[l]>>>15-t]=c,l++}}function o(e,t){for(var r=s.rev15,n=15-t,i=0;i<e.length;i+=2){var o=e[i]<<t-e[i+1];e[i]=r[o]>>>n}}const s=(a=Uint16Array,f=Uint32Array,{next_code:new a(16),bl_count:new a(16),ordr:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],of0:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],exb:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],ldef:new a(32),df0:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],dxb:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],ddef:new f(32),flmap:new a(512),fltree:[],fdmap:new a(32),fdtree:[],lmap:new a(32768),ltree:[],ttree:[],dmap:new a(32768),dtree:[],imap:new a(512),itree:[],rev15:new a(32768),lhst:new f(286),dhst:new f(30),ihst:new f(19),lits:new f(15e3),strt:new a(65536),prev:new a(32768)});var a,f;!function(){for(var e=0;e<32768;e++){var t=e;t=(4278255360&(t=(4042322160&(t=(3435973836&(t=(2863311530&t)>>>1|(1431655765&t)<<1))>>>2|(858993459&t)<<2))>>>4|(252645135&t)<<4))>>>8|(16711935&t)<<8,s.rev15[e]=(t>>>16|t<<16)>>>17}function r(e,t,r){for(;0!=t--;)e.push(0,r)}for(e=0;e<32;e++)s.ldef[e]=s.of0[e]<<3|s.exb[e],s.ddef[e]=s.df0[e]<<4|s.dxb[e];r(s.fltree,144,8),r(s.fltree,112,9),r(s.fltree,24,7),r(s.fltree,8,8),n(s.fltree,9),i(s.fltree,9,s.flmap),o(s.fltree,9),r(s.fdtree,32,5),n(s.fdtree,5),i(s.fdtree,5,s.fdmap),o(s.fdtree,5),r(s.itree,19,0),r(s.ltree,286,0),r(s.dtree,30,0),r(s.ttree,320,0)}();const c={table:function(){for(var e=new Uint32Array(256),t=0;t<256;t++){for(var r=t,n=0;n<8;n++)1&r?r=3988292384^r>>>1:r>>>=1;e[t]=r}return e}(),update:function(e,t,r,n){for(var i=0;i<n;i++)e=c.table[255&(e^t[r+i])]^e>>>8;return e},crc:function(e,t,r){return 4294967295^c.update(4294967295,e,t,r)}};class d{constructor(e,t){this._reader=e,this._rawEntry=t,this.name=t.name,this.nameBytes=t.nameBytes,this.size=t.uncompressedSize,this.compressedSize=t.compressedSize,this.comment=t.comment,this.commentBytes=t.commentBytes,this.compressionMethod=t.compressionMethod,this.lastModDate=null,this.isDirectory=0===t.uncompressedSize&&t.name.endsWith("/"),this.encrypted=!!(1&t.generalPurposeBitFlag)}async blob(e="application/octet-stream"){return await async function(e,r,n){const{decompress:i,fileDataStart:o}=await async function(e,t){if(1&t.generalPurposeBitFlag)throw new Error("encrypted entries not supported");const r=await l(e,t.relativeOffsetOfLocalHeader,30),n=await e.getLength(),i=p(r,0);if(67324752!==i)throw new Error(`invalid local file header signature: 0x${i.toString(16)}`);const o=m(r,26),s=m(r,28),a=t.relativeOffsetOfLocalHeader+r.length+o+s;let f;if(0===t.compressionMethod)f=!1;else{if(8!==t.compressionMethod)throw new Error(`unsupported compression method: ${t.compressionMethod}`);f=!0}const c=a,d=c+t.compressedSize;if(0!==t.compressedSize&&d>n)throw new Error(`file data overflows file bounds: ${c} + ${t.compressedSize} > ${n}`);return{decompress:f,fileDataStart:c}}(e,r),s=await async function(e,t,r,n){if(e.sliceAsBlob)return await e.sliceAsBlob(t,r,n);return await e.read(t,r)}(e,o,r.compressedSize,n);if(a=s,"undefined"!=typeof Blob&&a instanceof Blob)return s;var a;return new Blob([t(s.buffer)?new Uint8Array(s):s],{type:n})}(this._reader,this._rawEntry,e)}async arrayBuffer(){return await readEntryDataAsArrayBuffer(this._reader,this._rawEntry)}async text(){const e=await this.arrayBuffer();return y(new Uint8Array(e))}}async function l(e,t,r){return await e.read(t,r)}const u={unsigned:()=>0};function m(e,t){return e[t]+256*e[t+1]}function p(e,t){return e[t]+256*e[t+1]+65536*e[t+2]+16777216*e[t+3]}function w(e,t){return p(e,t)+4294967296*p(e,t+4)}const h=new TextDecoder;function y(e,r){return t(e.buffer)&&(e=new Uint8Array(e)),h.decode(e)}async function g(e,t,r,n){const i=t-20,o=await l(e,i,20);if(117853008!==p(o,0))throw new Error("invalid zip64 end of central directory locator signature");const s=w(o,8),a=await l(e,s,56);if(101075792!==p(a,0))throw new Error("invalid zip64 end of central directory record signature");const f=w(a,32),c=w(a,40);return b(e,w(a,48),c,f,r,n)}async function b(e,t,r,n,i,o){let s=0;const a=await l(e,t,r),f=[];for(let e=0;e<n;++e){const e=a.subarray(s,s+46),t=p(e,0);if(33639248!==t)throw new Error(`invalid central directory file header signature: 0x${t.toString(16)}`);const r={versionMadeBy:m(e,4),versionNeededToExtract:m(e,6),generalPurposeBitFlag:m(e,8),compressionMethod:m(e,10),lastModFileTime:m(e,12),lastModFileDate:m(e,14),crc32:p(e,16),compressedSize:p(e,20),uncompressedSize:p(e,24),fileNameLength:m(e,28),extraFieldLength:m(e,30),fileCommentLength:m(e,32),internalFileAttributes:m(e,36),externalFileAttributes:p(e,38),relativeOffsetOfLocalHeader:p(e,42)};if(64&r.generalPurposeBitFlag)throw new Error("strong encryption is not supported");s+=46;const n=a.subarray(s,s+r.fileNameLength+r.extraFieldLength+r.fileCommentLength);r.nameBytes=n.slice(0,r.fileNameLength),r.name=y(r.nameBytes);const i=r.fileNameLength+r.extraFieldLength,o=n.slice(r.fileNameLength,i);r.extraFields=[];let c=0;for(;c<o.length-3;){const e=m(o,c+0),t=c+4,n=t+m(o,c+2);if(n>o.length)throw new Error("extra field length exceeds extra field buffer size");r.extraFields.push({id:e,data:o.slice(t,n)}),c=n}if(r.commentBytes=n.slice(i,i+r.fileCommentLength),r.comment=y(r.commentBytes),s+=n.length,4294967295===r.uncompressedSize||4294967295===r.compressedSize||4294967295===r.relativeOffsetOfLocalHeader){const e=r.extraFields.find((e=>1===e.id));if(!e)return new Error("expected zip64 extended information extra field");const t=e.data;let n=0;if(4294967295===r.uncompressedSize){if(n+8>t.length)throw new Error("zip64 extended information extra field does not include uncompressed size");r.uncompressedSize=w(t,n),n+=8}if(4294967295===r.compressedSize){if(n+8>t.length)throw new Error("zip64 extended information extra field does not include compressed size");r.compressedSize=w(t,n),n+=8}if(4294967295===r.relativeOffsetOfLocalHeader){if(n+8>t.length)throw new Error("zip64 extended information extra field does not include relative header offset");r.relativeOffsetOfLocalHeader=w(t,n),n+=8}}const d=r.extraFields.find((e=>28789===e.id&&e.data.length>=6&&1===e.data[0]&&p(e.data,1)),u.unsigned(r.nameBytes));if(d&&(r.fileName=y(d.data.slice(5))),0===r.compressionMethod){let e=r.uncompressedSize;if(0!=(1&r.generalPurposeBitFlag)&&(e+=12),r.compressedSize!==e)throw new Error(`compressed size mismatch for stored file: ${r.compressedSize} != ${e}`)}f.push(r)}return{zip:{comment:i,commentBytes:o},entries:f.map((t=>new d(e,t)))}}async function v(e){let t;if(!("undefined"!=typeof Blob&&e instanceof Blob))throw new Error("unsupported source type");t=new r(e);const n=await t.getLength();if(n>Number.MAX_SAFE_INTEGER)throw new Error(`file too large. size: ${n}. Only file sizes up 4503599627370496 bytes are supported`);return await async function(e,t){const r=Math.min(65557,t),n=t-r,i=await l(e,n,r);for(let t=r-22;t>=0;--t){if(101010256!==p(i,t))continue;const r=new Uint8Array(i.buffer,i.byteOffset+t,i.byteLength-t),o=m(r,4);if(0!==o)throw new Error(`multi-volume zip files are not supported. This is volume: ${o}`);const s=m(r,10),a=p(r,12),f=p(r,16),c=m(r,20),d=r.length-22;if(c!==d)throw new Error(`invalid comment length. expected: ${d}, actual: ${c}`);const l=new Uint8Array(r.buffer,r.byteOffset+22,c),u=y(l);return 65535===s||4294967295===f?await g(e,n+t,u,l):await b(e,f,a,s,u,l)}throw new Error("could not find end of central directory. maybe not zip file")}(t,n)}window.unzipit=async function(e){const{zip:t,entries:r}=await v(e);return{zip:t,entries:Object.fromEntries(r.map((e=>[e.name,e])))}}}();